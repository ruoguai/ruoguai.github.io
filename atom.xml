<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[朱襄之]]></title>
  <subtitle><![CDATA[随笔]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhuxiangzhi.com/"/>
  <updated>2015-12-15T09:24:15.100Z</updated>
  <id>http://zhuxiangzhi.com/</id>
  
  <author>
    <name><![CDATA[zhuxiangzhi]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[字符串和单链表学习笔记]]></title>
    <link href="http://zhuxiangzhi.com/2015/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhuxiangzhi.com/2015/12/15/字符串和单链表学习笔记/</id>
    <published>2015-12-15T03:49:24.000Z</published>
    <updated>2015-12-15T09:24:15.100Z</updated>
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>技能的储从点滴开始，多一点记录或许就多一点希望。</strong></excerpt></p>
<ul>
<li><a id="more"></a>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>由于字符串和单链表有许多相似之处，比如字符串的连接、插入、删除、求长度等和单链表中的操作近似，因此放在一起学习。<br><strong>字符串的定义</strong>：字符串或串(String)是由数字、字母、下划线组成的一串字符。<br><strong>单链表的定义</strong>：单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br><strong>字符串的长度</strong>：在求字符串的长度时要注意sizeof和strlen的区别，如：</the></p>
<p>  char a[100]=”zhuxiangzhi”<br>那么sizeof(a)=100,即char类型占1个字节，100*1=100<br>而 strlen(a)=11，且字符串的长度不包括’\0’结尾字符</p>
</li>
</ul>
<p><strong>单链表的长度</strong>：为了获取单链表的长度可以使用循环遍历的方式进行如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLen</span><span class="params">(Node *pHead)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;         <span class="comment">//遍历链表size大小比链表的实际长度小1</span></span><br><span class="line">        pHead = pHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;    <span class="comment">//链表的实际长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串的复制</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[]=<span class="string">"zhuxiangzhi"</span>;</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">12</span>];  <span class="comment">//要记得'\0'</span></span><br><span class="line">	<span class="built_in">strcpy</span>(b,a);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* srcstr,<span class="keyword">char</span>* deststr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (srcstr!=<span class="literal">NULL</span>&amp;&amp;deststr!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> *tempstr=deststr;</span><br><span class="line">		<span class="keyword">while</span> ((*srcstr++=*deststr++)!=<span class="string">'\0'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> tempstr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>单链表的复制</strong>：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">&#123;</span><br><span class="line">	int</span> data;</span><br><span class="line">	struct <span class="keyword">node</span><span class="identifier"> </span><span class="title">*next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">node</span><span class="identifier"> </span><span class="title">*ListCopy</span>(<span class="keyword">node</span><span class="identifier"></span><span class="title">* L</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">node</span><span class="identifier"> </span><span class="title">*h</span>, *a;</span><br><span class="line">	if(L== NULL)</span><br><span class="line">	return NULL;</span><br><span class="line">	else if(L-&gt;<span class="variable">next=</span>=NULL)//链表只有一个头结点，无数据</span><br><span class="line">	return NULL;       </span><br><span class="line">	h = a = (<span class="keyword">node</span><span class="identifier"> </span><span class="title">*)malloc</span>(sizeof(<span class="keyword">node</span><span class="identifier"></span><span class="title">));//新链表的头结点（不保存数据）</span><br><span class="line">	a-</span>&gt;next = (<span class="keyword">node</span><span class="identifier"></span><span class="title">*)malloc</span>(sizeof(<span class="keyword">node</span><span class="identifier"></span><span class="title">));//新链表的第一个结点</span><br><span class="line">	a</span>=a-&gt;next;</span><br><span class="line">	while(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a-&gt;<span class="variable">data=</span>L-&gt;data;</span><br><span class="line">		if(L-&gt;next != NULL)//还没有复制完</span><br><span class="line">		&#123;</span><br><span class="line">			L = L-&gt;next;</span><br><span class="line">			a-&gt;next = (<span class="keyword">node</span><span class="identifier"></span><span class="title">*)malloc</span>(sizeof(<span class="keyword">node</span><span class="identifier"></span><span class="title">));//为新链表再分配一个结点空间</span><br><span class="line">			a</span> = a-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			a-&gt;next = NULL;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return h;//返回新链表的头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串的拼接</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">12</span>] = <span class="string">"zhuxiangzhi"</span>; </span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">9</span>] = <span class="string">"buruziyi"</span>;</span><br><span class="line">	<span class="keyword">char</span> *c = strAdd(a, b);  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	getchar();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strAdd</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">char</span> *c = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(a) + <span class="built_in">strlen</span>(b) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">char</span> *tempc = c; </span><br><span class="line">	<span class="keyword">while</span> (*a != <span class="string">'\0'</span>) </span><br><span class="line">	&#123;  </span><br><span class="line">		*c++ = *a++;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">while</span> ((*c++ = *b++) != <span class="string">'\0'</span>) </span><br><span class="line">	&#123;  </span><br><span class="line">	</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> tempc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>单链表的连接</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void connList(<span class="keyword">node</span><span class="identifier"> </span><span class="title">*N1</span>,<span class="keyword">node</span><span class="identifier"> </span><span class="title">*N2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">node</span><span class="identifier"> </span><span class="title">*p</span>=N1;</span><br><span class="line">	while(p-&gt;next!=NULL)  //线找到链表N1的最后一个节点</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;		</span><br><span class="line">	p-&gt;<span class="variable">next=</span>N2-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串的逆序</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">reveStr</span><span class="params">(<span class="keyword">char</span> *s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p=s;</span><br><span class="line">	<span class="keyword">char</span> *q=s;</span><br><span class="line">	<span class="keyword">while</span>(*q)</span><br><span class="line">	&#123;</span><br><span class="line">		++q;</span><br><span class="line">		q--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q&gt;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> t=*p;</span><br><span class="line">		*p++=*q;</span><br><span class="line">		q--=t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串替换</strong><br>在《剑指offer》一书中，提到一个关于字符串替换的相关题目，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceStr</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[],<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">string</span>==null &amp;&amp; length&lt;=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> OriLength=o;</span><br><span class="line">	<span class="keyword">int</span> numStr=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">string</span>[i]!=<span class="string">'\0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++OriLength;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">string</span>[i]==<span class="string">' '</span>)</span><br><span class="line">			++numStr;<span class="comment">//获取到字符串中空格的数量</span></span><br><span class="line">		++i;<span class="comment">//获取字符串的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> NewLength=Orilength+numStr*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(NewLength&gt;length)</span><br><span class="line">	retrun;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> indexOfOri=Orilength;</span><br><span class="line">	<span class="keyword">int</span> indexOfNew=NewLength;</span><br><span class="line">	<span class="keyword">while</span>(indexOfOri&gt;=<span class="number">0</span> &amp;&amp; indexOfNew&gt;indexOfOri)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOri]==<span class="string">" "</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span>[indexOfNew--]=<span class="string">'0'</span>;</span><br><span class="line">			<span class="built_in">string</span>[indexOfnew--]=<span class="string">'2'</span>;</span><br><span class="line">			<span class="built_in">string</span>[indexOfNew--]=<span class="string">'%'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span>[indexOfNew--]=<span class="built_in">string</span>[indexOfOri];</span><br><span class="line">		&#125;</span><br><span class="line">		--indexOfOri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><Excerpt in index | 首页摘要><br><strong>技能的储从点滴开始，多一点记录或许就多一点希望。</strong></p>
<ul>
<li>]]>
    
    </summary>
    
      <category term="C/C++ 单链表 字符串 操作" scheme="http://zhuxiangzhi.com/tags/C-C-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二维数组学习笔记]]></title>
    <link href="http://zhuxiangzhi.com/2015/12/14/TwoDimArray/"/>
    <id>http://zhuxiangzhi.com/2015/12/14/TwoDimArray/</id>
    <published>2015-12-14T09:32:14.000Z</published>
    <updated>2015-12-15T04:57:58.428Z</updated>
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>技能的储从点滴开始，多一点记录或许就多一点希望。</strong></excerpt></p>
<ul>
<li><a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文=""><br><strong>二维数组的定义</strong>，百科上讲以数组作为数组元素的数组，虽然拗口，但确实如此，以数组作为另一维度数组的元素。</the></li>
</ul>
<p><strong>二维数组的下标</strong>，二维数组在两个方向上“前进”，因此有两个下标，比如：int a[4][1]代表四行四列的int类型的数组两个维度下标的范围为0-3。</p>
<p><strong>二维数组的初始化</strong>，可以是连续的，也可以分行初始化：<br><code>int a[4][4]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};</code><br>不知道为什么大括号大括号非连续的，在hexo博客中不支持,暂且不写。<br>每个元素都为int类型因此在32位操作系统下各占4个字节。</p>
<p><strong>二维数组的指针:</strong><br>int (<em>p)[4]=a; 指针</em>p指向a的一维数组:<br>比如 <em>p是a[0][0]的地址
</em>p+2是a[0][2]的地址<br>以此类推 <em>p+i是a[0][i]的地址。<br>相应的（</em>p+1）是a[1][0]的地址<br>(<em>p+1)+i是a[1][i]的地址<br>(</em>p+j)+i是a[j][i]的地址。</p>
<p><strong>二维数组的查找:</strong><br>仍旧以上述a[4][4]为例，查找这个数组中是否存在10这个数字，如果存在返回其下标的值，如果不存在给出提示，并判断该数组中有几10这个数字。<br>正常情况下，我们会这样做：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">clock_t</span> starttime=clock();  </span><br><span class="line">	<span class="keyword">int</span> i,j;  </span><br><span class="line">	<span class="keyword">int</span> numFind=<span class="number">10</span>;  </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;  </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="keyword">if</span> (a[i][j]==numFind)  </span><br><span class="line">			&#123;  </span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"待查找的值在二维数组中的第："</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"行第"</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">"列。"</span>&lt;&lt;endl;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">clock_t</span> endtime=clock();  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(endtime-starttime)/CLOCKS_PER_SEC*<span class="number">1000</span>&lt;&lt;<span class="string">"ms"</span>&lt;&lt;endl;  </span><br><span class="line">	getchar();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/二维数组查找1.jpg" alt="正常查找"><br>这样可以求得待查找的下标值，程运行时间为8ms。</p>
<p>但是通过观察可以得知，每一行的后一个数要大于前一个数，下一个数要大于上一个数，在《剑指offer》一书中，作者给出以下做法：<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/二维数组.jpg" alt="二维数组"><br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/二维数组查找2.jpg" alt="二维数组查找剑指"><br>在这里由于数组行和列较少，我把while循环换成一个套嵌的for循环：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="keyword">clock_t</span> starttime=clock();  </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">11</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;;  </span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">3</span>;  </span><br><span class="line">	<span class="keyword">int</span> numFind=<span class="number">10</span>;  </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">3</span>;j&gt;<span class="number">0</span>;j--)  </span><br><span class="line">		&#123;  </span><br><span class="line">			<span class="keyword">if</span> (a[i][j]==numFind)  </span><br><span class="line">			&#123;  </span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"待查找的数在：第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"行，第:"</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">"列"</span>&lt;&lt;endl;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">clock_t</span> endtime=clock();  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(endtime-starttime)/CLOCKS_PER_SEC*<span class="number">1000</span>&lt;&lt;<span class="string">"ms"</span>&lt;&lt;endl;  </span><br><span class="line">	getchar();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样可以求得待查找的下标值，程运行时间为6ms,比直接查找要少了2ms。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/二维数组查找.jpg" alt="第二次查找"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><Excerpt in index | 首页摘要><br><strong>技能的储从点滴开始，多一点记录或许就多一点希望。</strong></p>
<ul>
<li>]]>
    
    </summary>
    
      <category term="C/C++ 二维数组 查找" scheme="http://zhuxiangzhi.com/tags/C-C-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Socket编程学习笔记]]></title>
    <link href="http://zhuxiangzhi.com/2015/12/12/Socket%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhuxiangzhi.com/2015/12/12/Socket编程学习笔记/</id>
    <published>2015-12-12T03:03:03.000Z</published>
    <updated>2015-12-13T06:37:14.762Z</updated>
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>技能的储从点滴开始，多一点记录或许就多一点希望。</strong></excerpt></p>
<ul>
<li><a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文=""><br>Socket编程是应用于网络程序的，因此必然少不了学习网络协议的相关知识，回头翻翻书，把OSI七层参考模型和TCP/IP协议画图如下简单理解一下。</the></li>
</ul>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/OSI%E4%B8%83%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.jpg" alt="OSI和TCP/IP协议"></p>
<p>  在简单的了解回顾之后发现，这种常识性的东西，经过多次的重复记忆，是不太容易忘记了。记得有笔试或面试中问路由协议是在哪一层，当时是回答错了的，在<strong>网络层</strong>。</p>
<p>  <strong>而socket编程主要是针对TCP和UDP协议的，这两个协议在OSI的传输层在TCP/IP四层的传输层。</strong></p>
<p>  还有<strong>数据封装</strong>的定义：对等协议之间交换信息单元被称为协议数据单元（PDU，Protocol Data Unit），在OSI参考模型中，下层把上层的PDU作为本层的数据封装，然后加入本层的头部。<br><strong>套接字的类型</strong></p>
<ol>
<li>流式套接字（<code>SOCKET_STREAM</code>）<br>提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送且按发送顺序接收，是基于TCP协议实现的。</li>
<li>数据报式套接字（<code>SOCK_DGRAM</code>）<br>提供面向无连接、不可靠的传输服务，数据报以独立包形式发送，不提供无错保证，数据可能丢失和重复，并且接收顺序混乱，数据报式套接字是基于UDP协议实现的。</li>
<li>原始套接字（<code>SOCK_RAW</code>）</li>
</ol>
<p>在socket编程中使用的函数主要有以下几个：</p>
<ol>
<li><p>WSAStartup，<strong>实现加载套接字库，进行套接字库的版本协商，确定将要使用的Socket版本</strong>。 函数原型 </p>
<p><code>int WSAStartup(WORD wVersionRequested,LPWSADATA lpWSAData);</code></p>
</li>
<li><p>socket函数 <strong>新建套接字</strong> 函数原型 </p>
</li>
</ol>
<pre><code>SOCKET socket(int af,int type,intprotocol)；
</code></pre><ol>
<li><p>bind函数 <strong>将套接字绑定到本地的地址和端口上</strong>函数原型<br><code>int bind(SOCKET s,const struct sockaddr FAR *name,int namelen);</code></p>
</li>
<li><p>listen函数 <strong>监听模式</strong>函数原型：<br><code>int listen(SOCKET s,int backlog);</code><br>监听模式，第二个参数是等待连接队列的最大长度。</p>
</li>
<li><p>accept函数，<strong>接收客户端发送的连接请求</strong></p>
<p><code>SOCKET accept(
SOCKET s,
Struct sockaddr FAR* addr,
Int FAR* addrlen);</code></p>
</li>
<li><p>send函数，<strong>通过一个已建立连接的套接字发送数据</strong></p>
<p><code>SOCKET send(
SOCKET s,、
Const char FAR* buf,
Int len,
Int flags
);</code></p>
</li>
<li><p>recv函数，<strong>通过一个已建立连接接收数据数据</strong></p>
<p><code>SOCKET recv(
SOCKET s,
Const char FAR* buf,
Int len,
Int flags
);</code></p>
</li>
<li><p>connect函数，<strong>将一个特定的套接字建立连接</strong></p>
<p><code>Int connect(
SOCKET s,
Const struct sockaddr FAR* name,
Int namelen,
);</code><br>还有Recvfrom函数<br>Sendto函数<br>Htons函数和htonl函数等几个函数。</p>
</li>
</ol>
<p>下面一例程是对Socket编程用于TCP通信的实践，该例程作者：<strong>集优</strong> 例程比较翔实，诸位可以用来参考。<br>原文地址：<a href="%E9%9B%86%E4%BC%98%E7%9A%84%E4%BE%8B%E7%A8%8B">http://jingyan.baidu.com/article/676629974557c254d51b84da.html</a><br>建工程和控件的设置不再赘述，其中事件显示EDIT编辑框记得设置：<br>Multiline和Vertical Scroll为True，这样编辑框中可以显示多行，且在竖直方向上可以有滚动条。</p>
<p>在类视图中添加一个派生于CSocket的类CSocketServer类，并使用类向导添加三个函数：<code>OnAccept();OnClose();OnReceive();</code><br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/%E7%B1%BB%E5%90%91%E5%AF%BC%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0.jpg" alt="类向导添加函数"><br>在SocketServer的头文件中包含对话框的头文件，并添加class类</p>
<pre><code>#include &quot;Server.h&quot;
class CServerDlg;
</code></pre><p>添加一个指向对话框的指针，如下图所示：<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%9A%84%E5%8C%85%E5%90%AB.jpg" alt="指针指向对话框"><br>对刚才类向导中添加的三个函数进行修改，实现功能</p>
<pre><code>void CServerSocket::OnAccept(int nErrorCode)
{
    m_pdlg-&gt;AddClient();
    CSocket::OnAccept(nErrorCode);
}
void CServerSocket::OnClose(int nErrorCode)
{
    m_pdlg-&gt;RemoveClient(this);
    CSocket::OnClose(nErrorCode);
}
void CServerSocket::OnReceive(int nErrorCode)
{
    m_pdlg-&gt;RecvData(this);
    CSocket::OnReceive(nErrorCode);
}
</code></pre><p>这三个m_pdlg-&gt;指向的都是在对话框中定义的函数。</p>
<p>在对话框头文件中包含SockeSever类的头文件等<br>为对话框类添加相应的函数和变量，然后实现这些函数的功能</p>
<pre><code>//定义函数和变量
CServerSocket* listenSocket;//监听状态，用于打开服务器
CPtrList m_clientList;//定义一个链表，用来存储用户
bool m_connect;
void AddClient();
void RemoveClient(CServerSocket* pSocket);
void RecvData(CServerSocket* pSocket);
void UpdataEvent(CString str);
BOOL Char2Byte(LPCWSTR strBuff,LPSTR destBuff,int nlen);
void sendMSG(CString str);
void ControlPC(CString AndroidControl);
</code></pre><p><strong>添加客户端</strong></p>
<pre><code> void CServerDlg::AddClient()
{
 CServerSocket* pSocket=new CServerSocket;
 pSocket-&gt;m_pdlg=this;
 listenSocket-&gt;Accept(*pSocket);
 pSocket-&gt;AsyncSelect(FD_READ|FD_WRITE|FD_CLOSE);
 m_clientList.AddTail(pSocket);//在链表的末端添加一个元素     或者将另外一个链表直接插入到这个链表的末尾
 m_user=m_clientList.GetCount();//GetCount返回这个链表中元     素的个数
 UpdateData(false);
 UpdataEvent(_T(&quot;用户连接服务器&quot;));
 sendMSG(_T(&quot;你好&quot;));
 }
</code></pre><p><strong>移除客户端</strong></p>
<pre><code>void CServerDlg::RemoveClient(CServerSocket* pSocket)
   {
   POSITION nPos=m_clientList.GetHeadPosition();//返回链表标元素的位置
   POSITION nTempPos=nPos;//中间变量
   while (nPos)
   {
       CServerSocket* pSockItem=(CServerSocket*)m_clientList.GetNext(nPos);
       if (pSockItem-&gt;m_hSocket==pSocket-&gt;m_hSocket)
       {
           pSockItem-&gt;Close();
           delete pSockItem;
           m_clientList.RemoveAt(nTempPos);
           m_user=m_clientList.GetCount();
           UpdateData(false);
           UpdataEvent(_T(&quot;用户离开&quot;));
           return;
       }
       nTempPos=nPos;
   }
   }
</code></pre><p><strong>接收数据</strong></p>
<pre><code>void CServerDlg::RecvData(CServerSocket* pSocket)
{
    //分配内存
    char* pData=NULL;
    pData=new char[1024];
    memset(pData,0,sizeof(char)*1024);
    UCHAR leng=0;
    CString str;
    if (pSocket-&gt;Receive(pData,1024,0)!=SOCKET_ERROR)
    {
        str=pData;
        ControlPC(str);
        sendMSG(str);
    }
    delete pData;
    pData=NULL;
}
</code></pre><p><strong>事件日志</strong></p>
<pre><code>void CServerDlg::UpdataEvent(CString str)
{
    CString string;
    CTime time=CTime::GetCurrentTime();
    str+=_T(&quot;\r\n&quot;);
    string = time.Format(_T(&quot;%Y/%m/%d %H:%M:%S  &quot;)) + str;
    int lastLine = m_event.LineIndex(m_event.GetLineCount() - 1);
    m_event.SetSel(lastLine+1,lastLine+2,0);
    m_event.ReplaceSel(string);

}
</code></pre><p><strong>字符串转比特数</strong></p>
<pre><code>BOOL CServerDlg::Char2Byte(LPCWSTR strBuff,LPSTR destBuff,int nlen)
{
    int n = 0;
    n = WideCharToMultiByte(CP_OEMCP, 0, strBuff, -1, destBuff, 0, 0, FALSE);//映射一unicode字符串到多字节字符串
    if (n&lt;nlen)
    return FALSE;
    WideCharToMultiByte(CP_OEMCP, 0, strBuff, -1, destBuff, nlen, 0, FALSE);
    return TRUE;
}
</code></pre><p><strong>发送消息</strong></p>
<pre><code>void CServerDlg::sendMSG(CString str)
{
    char *pSend = new char[str.GetLength()];
    memset(pSend, 0, str.GetLength()*sizeof(char));
    if (!Char2Byte(str.GetBuffer(0), pSend, str.GetLength()))
    {
        AfxMessageBox(_T(&quot;字符转换失败&quot;));
        delete pSend;
        return;
    }
    POSITION nPos = m_clientList.GetHeadPosition();
    while (nPos)
    {
        CServerSocket* pTemp = (CServerSocket*)m_clientList.GetNext(nPos);
        pTemp-&gt;Send(pSend, str.GetLength());
    }
    delete pSend;
}
</code></pre><p><strong>控制电脑</strong></p>
<pre><code>void CServerDlg::ControlPC(CString AndroidControl)
{
    if (AndroidControl == &quot;mop&quot;)
    {
        ShellExecute(NULL, _T(&quot;open&quot;), _T(&quot;C:\\Program Files (x86)\\KuGou\\KGMusic\\KuGou.exe&quot;), NULL, NULL, SW_SHOWNORMAL);
    }
    else if (AndroidControl == &quot;mcl&quot;)
    {
        DWORD id_num;
        HWND hWnd = ::FindWindow(_T(&quot;kugou_ui&quot;), NULL);
        GetWindowThreadProcessId(hWnd, &amp;id_num);          
        //注意：第二个参数是进程的ID，返回值是线程的ID。
        HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id_num);
        TerminateProcess(hd, 0);
    }
    else if (AndroidControl == &quot;mpl&quot; || AndroidControl == &quot;mpa&quot;)                //播放/暂停
    {
        keybd_event(VK_LMENU, 0, 0, 0);
        keybd_event(VK_F5, 0, 0, 0);
        keybd_event(VK_F5, 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_LMENU, 0, KEYEVENTF_KEYUP, 0);
    }
}
</code></pre><p><strong>防止按下ENTER或者ESC按键时退出</strong>   </p>
<pre><code>BOOL CServerDlg::PreTranslateMessage(MSG* pMsg)
{
    switch (pMsg-&gt;wParam)
    {
    case VK_RETURN:
    case VK_ESCAPE:
        return true; break;
    }
    return CDialogEx::PreTranslateMessage(pMsg);
}
</code></pre><p><strong>事件响应</strong></p>
<pre><code>void CServerDlg::OnBnClickedStartserver()
{
    if (m_connect)
    {
        delete listenSocket;
        listenSocket=NULL;
        m_connect=false;
        SetDlgItemText(IDC_STARTSERVER,_T(&quot;打开服务器&quot;));
        UpdataEvent(_T(&quot;系统关闭服务器&quot;));
        return;
    }
    listenSocket=new CServerSocket;
    listenSocket-&gt;m_pdlg=this;
    //指定对话框为主对话框
    if (!listenSocket-&gt;Create(m_port))
    {
        AfxMessageBox(_T(&quot;坚挺失败!&quot;));
        listenSocket-&gt;Close();
        return;
    }
    m_connect=true;
    SetDlgItemText(IDC_STARTSERVER,_T(&quot;关闭服务器&quot;));
    UpdataEvent(_T(&quot;系统打开服务器!&quot;));

}
</code></pre><p>至此，客户端代码的编写完成。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF.jpg" alt="服务器端"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><Excerpt in index | 首页摘要><br><strong>技能的储从点滴开始，多一点记录或许就多一点希望。</strong></p>
<ul>
<li>]]>
    
    </summary>
    
      <category term="编程 C/C++ Socket" scheme="http://zhuxiangzhi.com/tags/%E7%BC%96%E7%A8%8B-C-C-Socket/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何评价胡军版天龙八部（二）]]></title>
    <link href="http://zhuxiangzhi.com/2015/12/11/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E8%83%A1%E5%86%9B%E7%89%88%E5%A4%A9%E9%BE%99%E5%85%AB%E9%83%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://zhuxiangzhi.com/2015/12/11/如何评价胡军版天龙八部（二）/</id>
    <published>2015-12-11T08:02:26.000Z</published>
    <updated>2015-12-11T08:25:01.763Z</updated>
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>金庸巨著《天龙八部》是本人最喜欢的一部武侠小说。作为武侠小说的集大成者可谓金老的巅峰之作。而张纪中任制片人、胡军等人主演的03版《天龙八部》也是本人最喜欢的武侠剧甚至最喜欢的电视剧。</excerpt></p>
<ul>
<li><a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文=""><br><strong>接前文内容</strong></the></li>
</ul>
<p><strong>第六章 谁家弟子谁家院</strong><br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/shuijia.jpg" alt="shuijia"><br>朱丹臣和段誉机智的唐诗对和、一路躲、一路斗，斗到了刀白凤的门前。包不同曾说过段誉油嘴滑舌，从段誉和刀白凤的对话来看，绝非虚言。作为儿子，让父母重聚也是孝心一番。剧中对王妃的回归的盛大场面很多的画面。而这一切都是在木婉清的意料之外的，他不知道段誉的真实身份，不知道关于段誉的很多。甚至不知道她面对的是大理国的皇帝。 糊里糊涂的岳老三拜段誉为师<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/yuelaosanbaishi.jpg" alt="baishi"></p>
<p><strong>第七章 无计悔多情</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/wujihuiduoqing.jpg" alt="wujihui"></p>
<p>木婉清暗伤刀白凤，却不料伤了段誉。而后关于秦红棉是谁的对话，像极了原著中的对话。而这一切在段正淳揭开真相之后，徒留黯然神伤。随后秦红棉、甘宝宝出现，第一次学习到段正淳的能力。其实纵观全书中关于甘宝宝性格的描写，我觉得她才是段正淳最完美的情人。你我虽有情，但身为有夫之妇，不可再跨越这道坎，不然只会铸错。</p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/duanerduoqing.jpg" alt="duanerduoqing"></p>
<blockquote>
<p>段正淳走到钟夫人身边，笑道：“宝宝，我也香香你的脸，许不许？”钟夫人庄严道：“我是有夫之妇，决不能坏了我丈夫的名声。你只要碰我一下，我立时咬断舌头，死在你的面前。”<br>段正淳见她神色凛然，说得斩钉截铁，倒也不敢亵渎，问道：“宝宝，你嫁了怎么样的一个丈夫啊？”钟夫人道：“我丈夫样子丑陋，脾气古怪，武功不如你，人才不如你，更没你的富贵荣华。可是他一心一意的待我，我也一心一意的待他。我若有半分对不起他，教我甘宝宝天诛地灭，万劫不得超生。我跟你说，我跟他住的地方叫作‘万劫谷’，那名字便因我这毒誓而来。”</p>
</blockquote>
<p>不似原著中延庆太子到第七章才已青袍怪客的身份出现，大胡子《天龙八部》中第一集，段延庆已经出现并和萧峰有过交手。或许这样写更能突出萧峰是第一男主的地位吧。而在电视剧的第四集中，即无计悔多情一节，也出现了丐帮的聚会、康敏和马大元的出现，暂且不表。</p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/xiongmei.jpg" alt="xiongmei"></p>
<p>剧中这部分完全看不出二人的演技，但是截图中这份楚楚可怜，谁人会不心动？还好，有了台词的弥补，以及观众对二人服阴阳和合散之后反应的期待。 </p>
<p><strong>第八章 虎啸龙吟</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/yiyangzhi.jpg" alt="huxiao"></p>
<p>要说虎啸龙吟这个特效，是值五毛钱的。 段延庆的自信：</p>
<blockquote>
<p>青袍客道：“嘿嘿！你自称是大理国皇帝，我却只当你是谋朝篡位的乱臣贼子。你有胆子，尽管去调神策军、御林军来好了。我跟你说，我势力固然远不如你，可是要先杀段誉这小贼却易如反掌。你此刻跟我动手，数百招后或能胜得了我，但想杀我，却也千难万难。我只教不死，你便救不了段誉性命。</p>
</blockquote>
<p>黄眉僧的高深：<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/huangmei.jpg" alt="huangmei"></p>
<p>关于这段的描述，答主在另一个问题里截取了片段：如何驳倒算命先生？ - 知乎用户的回答 而关于通过《天龙八部》可以看到金庸棋力的回答，可以参看 @高飞龙 的回答 如何评价《天龙八部》中的围棋元素？ - 高飞龙的回答 在这之后，便是，段誉知道了钟灵原来也是自己的妹妹。</p>
<p><strong>第九章 换巢鸾凤</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/huanchaoluanfeng.jpg" alt="huanchao"></p>
<blockquote>
<p>钟万仇笑道：“孤男寡女，赤身露体的躲在一间黑屋子里，还能有什么好事做出来？哈哈，哈哈，大家瞧明白了！”<br>钟万仇大笑声中，只见一个青年男子披头散发，赤裸着上身走将出来，下身只系着一条短裤，露出了两条大腿，正是段誉，手中横抱着一个女子。那女子缩在他的怀里，也只穿着贴身小衣，露出了手臂、大腿、背心上雪白粉嫩的肌肤。<br>保定帝满脸羞惭。段正淳低下了头不敢抬起。刀白凤双目含泪，喃喃的道：“冤孽，冤孽！”高升泰解下长袍，要去给段誉披在身上。马五德一心要讨好段氏兄弟，忙闪身遮在段誉身前。南海鳄神叫道：“王八羔子，滚开！”<br>钟万仇哈哈大笑，十分得意，突然间笑声止歇，顿了一顿，蓦地里惨声大叫：“灵儿，是你么？”</p>
</blockquote>
<p>剧中这段的描写甚是精彩，有时间的话不妨重新观看。钟万仇机关算尽，却不曾想却害了自己，害了钟灵。是好是坏，谁也说不准。但从电视剧对原著的还原来看，不好扣分。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/zhongling1.jpg" alt="duaner1"><br>在段誉钟灵出现之后，段家兄弟悬在心中的时候落下了不说，段二竟然去调戏起了钟万仇，然而他怎又会知道，钟灵原来也是自己的女儿？ </p>
<p><strong>第十章 剑气碧烟横</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/jianqi.jpg" alt="jianqi"><br>五毛钱特效是从今年《盗墓笔记》开始流行的词，不过回头看很多剧，确实连五毛钱的特效都不值，比如这段，但是相较于TVB的特效，确实是有进步了的。 剑气碧烟横一章，个人觉得，金庸对于这种宏大的战场的表述已经足够精彩了，当然还有更精彩的在后面。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/jiumozhi.jpg" alt="jiunozhi"></p>
<p>为了所谓的慕容博所托，拜见枯荣大师，随后便参透枯荣大师所参的“枯禅”。鸠摩智不可不谓得道高僧，也是聪明之极，但其前半生总是放不掉贪、痴、嗔，也就有了后来的种种。一旦幡然醒悟，却又能迅速脱离这些，而这一切也都凸显了其极高的佛性、悟性，终成一代高僧。</p>
<p>鸠摩智带走段誉，也就出现了向来痴、从此醉。</p>
<p><strong>未完待续</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><Excerpt in index | 首页摘要><br>金庸巨著《天龙八部》是本人最喜欢的一部武侠小说。作为武侠小说的集大成者可谓金老的巅峰之作。而张纪中任制片人、胡军等人主演的03版《天龙八部》也是本人最喜欢的武侠剧甚至最喜欢的电视剧。</p>
<ul>
<li>]]>
    
    </summary>
    
      <category term="胡军 天龙八部 刘涛 张纪中" scheme="http://zhuxiangzhi.com/tags/%E8%83%A1%E5%86%9B-%E5%A4%A9%E9%BE%99%E5%85%AB%E9%83%A8-%E5%88%98%E6%B6%9B-%E5%BC%A0%E7%BA%AA%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何评价胡军版天龙八部（一）]]></title>
    <link href="http://zhuxiangzhi.com/2015/12/10/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E8%83%A1%E5%86%9B%E7%89%88%E5%A4%A9%E9%BE%99%E5%85%AB%E9%83%A8/"/>
    <id>http://zhuxiangzhi.com/2015/12/10/如何评价胡军版天龙八部/</id>
    <published>2015-12-10T11:09:59.000Z</published>
    <updated>2015-12-11T03:26:54.953Z</updated>
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>金庸巨著《天龙八部》是本人最喜欢的一部武侠小说。作为武侠小说的集大成者可谓金老的巅峰之作。而张纪中任制片人、胡军等人主演的03版《天龙八部》也是本人最喜欢的武侠剧甚至最喜欢的电视剧。</excerpt></p>
<ul>
<li><a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文=""><br>这个我一定要回答！</the></li>
</ul>
<p><strong>先给出我自己的观点，胡军版《天龙八部》是大胡子所参与拍摄（导演、制片人）武侠剧中最完美的，也是包括TVB等武侠剧中我认为最为精彩的一部。</strong></p>
<p>本剧我应该看了不止五遍，有精彩的地方或者契合点我都会截图，但是因为误删所有存档都丢了导致现在只能再重新看一遍。慢慢坑，结合原著来贴图，图多，流量慎点。</p>
<p>本答案主要从以下几个方面来表述： </p>
<p><strong>一、部分截图和原著的契合。按章节进行，每一个章节尽量去寻找在剧中对应的截图，由于《天龙八部》章节名由几首填词组成，读起来朗朗上口，看起来也方便顺便带诸位回头看下天龙全书。</strong><br><strong>二、既然谈到如何评价，自然少不了对比，对比不谈黄日华版的，似乎大家也都回不到童年的那种“江湖”感。</strong><br><strong>关于动作指导答主不太熟悉，但是可以从几场经典场面刻画来进行分析。</strong><br><strong>题主提到了片尾曲《宽恕》，其实插曲《仰望》也有分析的价值。</strong></p>
<p><strong>先从手中有的截图开始</strong></p>
<p><strong>第一章 青衫磊落险峰行</strong><br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/qingshanleiluo.jpg" alt="qingshan"></p>
<p>看过胡军版《天龙八部》的朋友或许都还记得，剧情并不是按照原著中从段誉开始的，而是雁门关一战众高手和萧远山的血腥场面开始。既然按照原著章节来，还是从段誉开始截图吧。 截图中“山红涧碧纷烂漫”出自韩愈《山石》，在《天龙八部》原著中并无提及，且看：</p>
<blockquote>
<p>山石荦确行径微，黄昏到寺蝙蝠飞。<br>升堂坐阶新雨足，芭蕉叶大栀子肥。<br>僧言古壁佛画好，以火来照所见稀。<br>铺床拂席置羹饭，疏粝亦足饱我饥。<br>夜深静卧百虫绝，清月出岭光入扉。<br>天明独去无道路，出入高下穷烟霏。<br>山红涧碧纷烂漫，时见松枥皆十围。<br>当流赤足踏涧石，水声激激风吹衣。<br>人生如此自可乐，岂必局束为人鞿？<br>嗟哉吾党二三子，安得至老不更归。</p>
</blockquote>
<p>提到这首诗，实在是牵强附会，不过答主觉得，既然大胡子有心让这首诗出现在字幕中，自然有其道理。这首诗所述应该是出游过程中所见所感。而段誉的出游却不是如此心境，父亲、伯父，逼迫自己学武，而段誉又志不在此，因此烦闷而逃出家庭的禁锢。竟而碰到了无量剑派和神农帮一堆杂七杂八的事情，也开启了段誉的江湖之旅。</p>
<p>《山石》中“僧言古壁佛画好，以火来照所见稀”二句也可揭示《天龙八部》的主题—-求不得。 段誉作为皇家世子，未来皇位继承人，段氏武学的承载者，却一心向佛，不愿习武，更不愿杀生。却在接下来的行走江湖中，不知不觉习武、误打误撞伤人。</p>
<p>大胡子的金庸剧的拍摄确实有许多值的诟病的地方，但单单从选景来看，还是高出其他武侠制作一筹的。 截图中（不是青衫，或许是不敢颠覆陈浩民版本或者说青衫在视觉效果上不如林志颖穿一袭白衣）林志颖段誉轻摇折扇，漫步短吟。对段誉这并无江湖经历的贵公子的描述真的是恰到好处。红色枫叶，雾里山峰，让人如痴如醉。带我们走入这个气势磅礴的江湖。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/zhongling.jpg" alt="zhongling"></p>
<p>钟灵的可爱和鬼精灵，众位朋友可还记得“你吃瓜子不吃”？</p>
<p><strong>第二章 玉璧月华明</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/shenxianjiejie.jpg" alt="shenxianjiejie"></p>
<p>电视剧中是有这部分的相关拍摄的。但是并没有原著中那么具体的描述，比如扯掉藤蔓，擦拭干净看到月光反射照在玉璧上，只是段誉轻轻擦拭之后，看到练剑的影子。截图不太好截，而且单单贴这张截图会显突兀。只好委曲求全，贴一下李秋水小妹（书中并未提到李沧海三个字）的像了。</p>
<p>下面是《天龙八部》中对玉像的描述：</p>
<blockquote>
<p>见这女子虽是仪态万方，却似并非活人，大着胆子再行细看，才瞧出乃是一座白玉雕成的玉像。&gt;这玉像与生人一般大小，身上一件淡黄色绸衫微微颤动；更奇的是一对眸子莹然有光，神彩飞扬&gt;。<br>……<br>玉像脸上白玉的纹理中隐隐透出晕红之色，更与常人肌肤无异。段誉侧过身子看那玉像时，只见&gt;她眼光跟着转将过来，便似活了一般。他大吃一惊，侧头向右，玉像的眼光似乎也对着他移动。&gt;不论他站在那一边，玉像的眼光始终向着他，眼光中的神色更是难以捉摸，似喜似爱，似是情意&gt;深挚，又似黯然神伤。</p>
</blockquote>
<p>电视剧的拍摄是从远到近慢慢放大而后转动视角给在了这个玉像上的。当然，书中写到是用黑宝石雕刻而成而不是这般粗制滥造，除了玉像眼神的单调，其他比如绸衫微微颤动是可以感触到的。同时加上了段誉痴傻的表情，来衬托玉像的美，哦不，是玉像的那个神，传神。 段誉去万劫谷找钟万仇求救，误打误撞的碰到无量派私奔弟子，又机缘巧合的得一身几乎无人匹敌的神功。然后，然后。。。马上要遇到木婉清，婉妹，华妃凉凉。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/laoyanyuan.jpg" alt="laoyanyuan"><br>老戏骨的演技，不得不服。 </p>
<p><strong>第三章 马疾幽香</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/majiyouxiang.jpg" alt="majiyouxiang"></p>
<blockquote>
<p>只觉自己后颈靠在一人身上，鼻中闻到阵阵幽香，正是那黑衣女郎身上的香气。蹄声得得，既轻&gt;且稳，敌人的追逐喊杀声已在身后渐渐远去。黑玫瑰全身黑毛，那女郎全身黑衣，黑夜中一团漆&gt;黑，睁眼什么都瞧不见，惟有一股芬馥之气缭绕鼻际，更增几分诡秘。<br>黑玫瑰奔了一阵，敌人喧叫声已丝毫不闻。段誉道：“姑娘，没料到你这么好本事，请放我起来&gt;吧。”黑衣女郎哼了一声，并不理睬。段誉手脚给带子紧紧缚住了，黑玫瑰每跨一步，带子束缚处&gt;便收紧一下，手脚步越来越痛，加之脚高头低，斜悬马背，头脑中一阵阵的晕眩，当真说不出的&gt;难受，又道：“姑娘，快放了我！”</p>
</blockquote>
<p>不谈选角，蒋欣对木婉清这个角色的刻画可谓入木三分，刁蛮、任性、外表冷峻、内心温热、直率等性格一一表现出来。而黑衣、黑玫瑰、黑面纱的选择也非钟汉良版的黑丝袜套头可比。<br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/wanxiqingyang.jpg" alt="muwanqing"><br>想来知乎上的诸位朋友对这两句也已经足够熟悉，不再做过多解释了。</p>
<p>第四章 崖高人远</p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/yagaorenyuan.jpg" alt="yagaorenyuan"></p>
<p>不知道诸位看到这个镜头的时候作何想，我这个镜头来回看了很多遍，除了美就是美。在崖高人远这一章节中，被岳老三逼到毫无退路的木婉清，以真面目示段誉，并以身相许。这一段的刻画极其尊重原著，包括很小的细节，每一个对话。 <strong>当然配以岳老三的“傻”更增一乐。</strong><br><img src="http://7xp2mn.com1.z0.glb.clouddn.com/yuelaosan.jpg" alt="yuelaosan"><br>如若从诨号来看，南海鳄神岳老三是恶人吗？从书中并没有正面写到岳老三有多恶，而是傻的可爱，和包不同、风波恶一样，他们是没有主角光环的配角、炮灰。但是他们的存在绝不仅仅是为了衬托主角，而是真实的存在，有血有肉的。<strong>而张纪中版《天龙八部》更是让这些小角色承载了更多的东西。</strong></p>
<p><strong>第五章 微步彀纹生</strong></p>
<p><img src="http://7xp2mn.com1.z0.glb.clouddn.com/weibu.jpg" alt="weibu"></p>
<p>此时，四大恶人已出其三，对比起叶二娘和云中鹤的劣迹斑斑，更是凸显了岳老三的可爱。而后便是段誉练习《凌波微波》这门功夫了，想来喜欢曹子建或者玩三国杀的朋友都还记得那些经典的句子。 截图也是不太清晰，但足以彰显章节标题：微步彀纹生。</p>
<blockquote>
<p>这般练了数日，‘凌波微步’已走得颇为纯熟，不须再数呼吸，纵然疾行，气息也已无所窒滞。心意既畅，跨步时渐渐想到‘洛神赋’中那些与‘凌波微步’有关的句子：“仿佛兮若轻云之蔽月，飘飘兮若流风之回雪”，“忽焉纵体，以遨以嬉”，“神光离合，乍阴乍阳”，“辣轻躯以鹤立，若将飞而未翔”，“体迅飞凫，飘忽若神”，“动无常则，若危若安。进止难期，若往若还”。&gt;</p>
</blockquote>
<p>在回头寻找木婉清的过程中，段公子凌波微步神功已成，再也无人能阻挡他的步伐了。更神奇的是：莽牯朱蛤吃进肚，从此百毒都让路。初读天龙并不了解莽牯朱蛤的朋友，谁又能知道这是金老赋予段誉的主角光环呢。大胡子在此剧中对这一段的拍摄也可谓对原著的还原，精彩之极。 </p>
<p><strong>未完待续</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><Excerpt in index | 首页摘要><br>金庸巨著《天龙八部》是本人最喜欢的一部武侠小说。作为武侠小说的集大成者可谓金老的巅峰之作。而张纪中任制片人、胡军等人主演的03版《天龙八部》也是本人最喜欢的武侠剧甚至最喜欢的电视剧。</p>
<ul>
<li>]]>
    
    </summary>
    
      <category term="胡军 天龙八部 刘涛 张纪中" scheme="http://zhuxiangzhi.com/tags/%E8%83%A1%E5%86%9B-%E5%A4%A9%E9%BE%99%E5%85%AB%E9%83%A8-%E5%88%98%E6%B6%9B-%E5%BC%A0%E7%BA%AA%E4%B8%AD/"/>
    
  </entry>
  
</feed>
